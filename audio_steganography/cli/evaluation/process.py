#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# File: process.py
# Author: Petr Kabelka <xkabel09 at stud.fit.vutbr.cz>

"""This file contains the main() function for the program to process audio
steganography methods evaluation results.
"""

from ..cli_utils import get_attr
import argparse
import uuid
from typing import Tuple, Any, List
from pathlib import Path
import pandas as pd
import json

def parse_args() -> Tuple[Any, argparse.ArgumentParser]:
    parser = argparse.ArgumentParser()

    parser.add_argument(
        '-d',
        '--data',
        metavar='PATH',
        action='store',
        help='path to a directory containing dataset evaluation results; '+
            'expected structure is: <dataset root>/<datasets>/<categories>/<files>; '+
            'directories starting with "." will be ignored',
        required=True)

    parser.add_argument(
        '-o',
        '--output',
        metavar='OUTPUT_DIR',
        action='store',
        help='path to an output directory; EXISTING FILES WILL BE OVERWRITTEN',
        default=None)

    parser.add_argument(
        '--graphs',
        action='store_true',
        help='generate graphs of the output tables',
        default=False)

    # Parse all args
    args = parser.parse_args()
    return args, parser

def set_dtypes(df: pd.DataFrame) -> pd.DataFrame:
    df['dataset'] = df['dataset'].astype('category')
    df['category'] = df['category'].astype('category')
    df['file'] = df['file'].astype('category')
    df['method'] = df['method'].astype('category')
    df['params'] = df['params'].astype('category')
    df['secret_bits'] = df['secret_bits'].astype('category')
    df['modification'] = df['modification'].astype('category')
    return df

def process_data(df: pd.DataFrame) -> Tuple[List, List]:
    """This function filters the input DataFrame evaluation results and returns
    the filtered tables and plots.

    Parameters
    ----------
    df : DataFrame
        Table containing all of the evaluation results.

    Returns
    -------
    dfs : List[DataFrame]
        List of dataframes with filtered tables ready for graph plotting.
    figures : List[Figure]
        List of matplotlib figures generated by pandas.
    """
    dfs = []
    figures = []

    # inches per centimeter
    cm = 1/2.54

    df_useful_cols = df.query('time_to_encode != inf | time_to_decode != inf')
    df_useful_cols = df_useful_cols.drop(['mse', 'rmsd', 'time_to_encode', 'time_to_decode'], axis=1)

    # No method modifications, mean values grouped by method and params
    df_no_mod_all_param = df_useful_cols[df_useful_cols['modification'] == 'no_modification']
    df_no_mod_all_param_group = df_no_mod_all_param.groupby(['method', 'params'])
    df_no_mod_all_param_group_mean = df_no_mod_all_param_group.mean(numeric_only=True).reset_index()
    df_no_mod_all_param_group_mean = df_no_mod_all_param_group_mean.dropna()
    df_no_mod_all_param_group_mean.name = 'no_modifications_all_params_mean'

    def params_compact(method, params):
        params = json.loads(params)
        if method.startswith('echo'):
            params.pop('delay_search', None)
            params.pop('decay_rate', None)

        params_str = []
        for k, v in params.items():
            key = str(k).replace('_', ' ')
            val = str(v).replace('_', ' ')

            if method == 'lsb' and key == 'only needed':
                if v == True:
                    params_str.append(f'{key}')
                    continue
                else:
                    continue

            params_str.append(f'{key}={val}')

        return ', '.join(params_str)

    methods = df_no_mod_all_param_group_mean['method'].unique()
    for method in methods:
        df_no_mod_all_param_group_mean_method = df_no_mod_all_param_group_mean.copy().query('method == @method')
        df_no_mod_all_param_group_mean_method['params'] = df_no_mod_all_param_group_mean_method['params'].apply(lambda params: params_compact(method, params))
        df_no_mod_all_param_group_mean_method = df_no_mod_all_param_group_mean_method.sort_values('psnr_db', ascending=False)
        df_no_mod_all_param_group_mean_method = df_no_mod_all_param_group_mean_method.sort_values('snr_db', ascending=False)
        df_no_mod_all_param_group_mean_method = df_no_mod_all_param_group_mean_method.sort_values('ber_percent')
        df_no_mod_all_param_group_mean_method.name = f'no_mod_params_mean_values_{method}'
        dfs.append(df_no_mod_all_param_group_mean_method)

        fig = df_no_mod_all_param_group_mean_method.plot.bar(
            x='params',
            rot=90,
            figsize=(17*cm, 12*cm),
            title=df_no_mod_all_param_group_mean_method.name,
        ).get_figure()
        fig.tight_layout()
        figures.append(fig)

    # Method modifications on clean methods with best params
    def params_filter(method, params):
        params = json.loads(params)
        method_params = {
            'echo_single': {'d0': 200, 'd1': 250, 'alpha': 0.5},
            'echo_bipolar': {'d0': 200, 'd1': 250, 'alpha': 0.5},
            'echo_bf': {'d0': 200, 'd1': 250, 'alpha': 0.5},
            'echo_bipolar_bf': {'d0': 200, 'd1': 250, 'alpha': 0.5},
            'lsb': {'depth': 1, 'only_needed': True},
            'phase': {},
            'dsss': {'alpha': 0.005},
            'silence_interval': {'min_silence_len': 400},
            'dsss_dft': {'alpha': 0.0025},
            'tone_insertion': {'f0': 18757, 'f1': 21703},
        }

        for k, v in method_params.get(method, {}).items():
            if v != params.get(k, None):
                return False
        return True

    methods = df_useful_cols['method'].unique()
    for method in methods:
        df_mod = df_useful_cols.query('method == @method & modification != "no_modification"')
        # df_mod = df_mod[df_mod['modification'] != 'no_modification']
        df_mod = df_mod[df_mod['params'].apply(lambda params: params_filter(method, params))]
        df_mod_group = df_mod.groupby(['method', 'modification'])
        df_mod_group_mean = df_mod_group.mean(numeric_only=True).reset_index()
        df_mod_group_mean = df_mod_group_mean.dropna()
        df_mod_group_mean.name = f'modifications_mean_values_{method}'

        dfs.append(df_mod_group_mean)

        fig = df_mod_group_mean.plot.bar(
            x='modification',
            rot=45,
            figsize=(17*cm, 12*cm),
            title=df_mod_group_mean.name,
        ).get_figure()
        fig.tight_layout()
        figures.append(fig)

    return dfs, figures

def main():
    """The main function of the evaluation data processing program.
    """
    args, _ = parse_args()
    output_dir = Path(args.output)

    file_dfs = []

    dataset_root = Path(args.data)
    datasets = [
        x for x in dataset_root.iterdir()
        if x.is_dir() and not x.name.startswith('.')
    ]
    for dataset in datasets:
        categories = [
            x for x in dataset.iterdir()
            if x.is_dir() and not x.name.startswith('.')
        ]
        for category in categories:
            files = [
                x for x in category.iterdir() if
                x.is_file() and not x.name.startswith('.')
                            and x.suffix.lower() == '.csv'
            ]
            for file in files:
                file_dfs.append(
                    pd.read_csv(
                        file,
                        sep=';',
                    )
                )

    df_all = pd.concat(file_dfs, ignore_index=True)
    df_all.loc[df_all['modification'].isna(), 'modification'] = 'no_modification'
    df_all = set_dtypes(df_all)

    dataframes, figures = process_data(df_all)

    # write all DataFrames to CSVs
    for df in dataframes:
        df_name = get_attr(df, 'name')
        df_name = df_name if df_name is not None else str(uuid.uuid4())
        df_name = df_name.replace('_', '-')

        df.columns = df.columns.str.replace('_', ' ')

        # replace underscores in method names with spaces
        try:
            methods = df['method'].unique()
            mapping = {old: new for old, new in zip(methods, [x.replace('_', ' ') for x in methods])}
            df['method'] = df['method'].cat.rename_categories(mapping)
        except:
            pass

        df.to_csv(
            output_dir / f'{df_name}.csv',
            sep=';',
            index=False,
        )

    if args.graphs:
        # write all figures to PDFs
        for fig in figures:
            fig_name = fig.axes[0].get_title()
            fig_name = fig_name if fig_name != '' else str(uuid.uuid4())
            fig.savefig(output_dir / f'{fig_name}.pdf')

if __name__ == '__main__':
    main()
